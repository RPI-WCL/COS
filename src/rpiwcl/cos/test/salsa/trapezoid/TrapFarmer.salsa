module rpiwcl.cos.test.salsa.trapezoid;

import java.io.*;
import java.util.*;
import rpiwcl.cos.test.salsa.trapezoid.*;
import rpiwcl.cos.runtime.CosInterface;


/* Trap.salsa -- Parallel Trapezoidal Rule
 *
 * Input: Optinal. a and b, the left and right endpoints of the integral.n the number of trapezoids.
 * Output:  Estimate of the integral from a to b of f(x)
 *    using the trapezoidal rule and n trapezoids.
 *
 * Algorithm:
 *    1.  Each actor calculates "its" interval of
 *        integration.
 *    2.  Each actor estimates the integral of f(x)
 *        over its interval using the trapezoidal rule.
 *    3a. Each actor sends its results to the main actor.
 *    3b. The main actor sums the calculations received from
 *        the individual actors and prints the result.
 *
 * Note:  f(x) is hardwired.
 *
 */

behavior TrapFarmer {
    double      a = 0.0;        // Left endpoint             
    double      b = 1.0;        // Right endpoint            
    int         n = 1024;       // Number of trapezoids      
    int         numWorkers = 2;   // The number of actors   
    long        initialTime;    // Starting Time

    String      nameServer;
    Vector      theaters;

    // progress report
    int         numTasks = 0;
    int REPORT_PROGRESS_INTERVAL = 10000; // report progress every this milliseconds
    int[]       completedTasks;
    String      cosIpAddr;
    int         cosPort;
    String      appName;
    CosInterface cosIf;

    void submitJob( int a, int b, int n, int numWorkers, 
                    String nameServer, Vector theaters,
                    String cosIpAddr, int cosPort, String appName ) {
        this.a = a;
        this.b = b;
        this.n = n;
        this.numTasks = n;
        this.numWorkers = numWorkers;
        this.nameServer = nameServer;
        this.theaters = theaters;
        this.completedTasks = new int[numWorkers];
        this.cosIpAddr = cosIpAddr;
        this.cosPort = cosPort;
        this.appName = appName;
        this.cosIf = new CosInterface( cosIpAddr, cosPort, appName );
        
        distributeWork()@
        displayResults(token)@
        endTimer()@currentContinuation;
    }


    Double distributeWork(){
        double h = (b-a)/n; // Trapezoid base length    
        int local_n = n/numWorkers;   // Number of trapezoids for  
        double   local_a;   // Left endpoint my process 
        double   local_b;   // Right endpoint my process
        TrapWorker[] workers = new TrapWorker[numWorkers];
        ArrayList uans = new ArrayList();

        // migrate actors to theaters
        for (int i=0; i<numWorkers; i++){
            String uan = "uan://" + nameServer + "/a" + i;
            String ual = "rmsp://" + theaters.get(i % theaters.size()) + "/a" + i;
            uans.add( uan );
            
            standardOutput<-println("Sending actor " + uan +" to " + ual );
            workers[i] = new TrapWorker( i, this.getUAN().toString() ) at  
                (new UAN( uan ), new UAL( ual ));
        }

        cosIf.open();
        cosIf.reportNumTasks( numTasks );
        cosIf.registerWorkers( uans );
        cosIf.reportProgress( 0 ); // initial report

        //start computation
        standardOutput<-println(">>>>>>Starting the computation");
        initialTime = System.currentTimeMillis();
        
        join{                  
            for (int i=0;i<numWorkers;i++){

                /* Length of each actor's interval of
                 * integration = local_n*h.  So my interval
                 * starts at: */
    
                local_a = a + i * local_n * h;
                local_b = local_a + local_n * h;
                workers[i]<-trap(local_a, local_b, local_n, h);
            }                       
        }@addUpIntegrals(token)@currentContinuation;
    }

    void endTimer(){
        long finalTime = System.currentTimeMillis();
        long runningTime = finalTime - initialTime;
        standardOutput<-println("Running time for Trapezoidal" + 
                                " approximation is "+(runningTime/1000)+" sec");
    }

    double addUpIntegrals(Object[] results){
        //receives the integral calculated from each actor's work
        double total = 0.0;
        for (int i = 0; i<results.length; i++){
            total += ((Double)results[i]).doubleValue();
        }
        return total;
    }

    void displayResults(double result){
        standardOutput<-println("With n = "+n+" trapezoids, our estimate of the integral on ("+a+","+b+")="+result);

        cosIf.close();
    }

    long lastReportTime = 0;
    void reportProgress( int id, int completed ) {
        long currentTime = System.currentTimeMillis();
        completedTasks[id] = completed;      // #total completed tasks is sent from workers

        if (lastReportTime + REPORT_PROGRESS_INTERVAL <= currentTime) {
            lastReportTime = currentTime;

            int sum = 0;
            for (int i = 0; i < numWorkers; i++)
                sum += completedTasks[i];

            System.out.println( " " + sum + "/" + numTasks + " (" + 
                                (100 * sum / numTasks) + "%) completed" );

            cosIf.reportProgress( sum );
        }
    }

}
