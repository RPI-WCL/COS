module rpiwcl.cos.test.salsa.trapezoid2;

import java.io.*;
import java.util.*;
import rpiwcl.cos.test.salsa.trapezoid2.*;


/* Trap.salsa -- Parallel Trapezoidal Rule
 *
 * Input: Optinal. a and b, the left and right endpoints of the integral.n the number of trapezoids.
 * Output:  Estimate of the integral from a to b of f(x)
 *    using the trapezoidal rule and n trapezoids.
 *
 * Algorithm:
 *    1.  Each actor calculates "its" interval of
 *        integration.
 *    2.  Each actor estimates the integral of f(x)
 *        over its interval using the trapezoidal rule.
 *    3a. Each actor sends its results to the main actor.
 *    3b. The main actor sums the calculations received from
 *        the individual actors and prints the result.
 *
 * Note:  f(x) is hardwired.
 *
 */

behavior TrapFarmer {
    double      a = 0.0;        // Left endpoint             
    double      b = 1.0;        // Right endpoint            
    int         numWorkers = 2;   // The number of actors   
    long        initialTime;    // Starting Time

    String      nameServer;
    ArrayList   configs;

    // progress report
    int         numTasks = 0;
    int REPORT_PROGRESS_INTERVAL = 10000; // report progress every this milliseconds
    int[]       completedTasks;
    String      appName;

    void submitJob( int a, int b, int numTasks, int numWorkers, 
                    String nameServer, ArrayList configs ) {
        this.a = a;
        this.b = b;
        this.numTasks = numTasks;
        this.numWorkers = numWorkers;
        this.nameServer = nameServer;
        this.configs = configs;
        this.completedTasks = new int[numWorkers];
        
        distributeWork()@
        displayResults(token)@
        endTimer()@currentContinuation;
    }

    Double distributeWork(){
        TrapWorker[] workers = new TrapWorker[numWorkers];
        ArrayList uans = new ArrayList();

        // migrate actors to theaters
        int id = 0;
        for (int i = 0; i < configs.size(); i++) {
            String config = (String)configs.get( i );
            String[] splits = config.split( "," );
            String theater = splits[1];

            System.out.println( "Sending " + splits[3] + " actors to " + 
                                splits[0] + "(" + splits[2] + ")" );
            
            for (int j = 0; j < Integer.parseInt( splits[3] ); j++) {
                String uan = "uan://" + nameServer + "/a" + id;
                String ual = "rmsp://" + theater + "/a" + id;
                System.out.println(" Sending actor " + uan +" to " + ual );
                workers[id] = new TrapWorker( id, this.getUAN().toString() ) at  
                        (new UAN( uan ), new UAL( ual ));
                id++;
            }
        }

        //start computation
        System.out.println(">>>>>>Starting the computation");
        initialTime = System.currentTimeMillis();

        double  h = (b-a)/numTasks; // Trapezoid base length    
        int local_n;       // Number of trapezoids for
        double  local_a;   // Left endpoint my process 
        double  local_b;   // Right endpoint my process
        int     total_n = 0;

        id = 0;
        join{
            for (int i = 0; i < configs.size(); i++) {
                String config = (String)configs.get( i );
                String[] splits = config.split( "," );

                for (int j = 4; j < splits.length; j++) {
                    local_n = Integer.parseInt( splits[j] );
                    local_a = a + total_n * h;
                    local_b = local_a + local_n * h;

                    workers[id]<-trap(local_a, local_b, local_n, h);

                    total_n += local_n;
                    id++;
                }
            }
        }@addUpIntegrals(token)@currentContinuation;
    }

    void endTimer(){
        long finalTime = System.currentTimeMillis();
        long runningTime = finalTime - initialTime;
        standardOutput<-println("Running time for Trapezoidal" + 
                                " approximation is "+((double)runningTime/1000)+" sec");
    }

    double addUpIntegrals(Object[] results){
        //receives the integral calculated from each actor's work
        double total = 0.0;
        for (int i = 0; i<results.length; i++){
            total += ((Double)results[i]).doubleValue();
        }
        return total;
    }

    void displayResults(double result){
        standardOutput<-println("With n = "+numTasks+" trapezoids, our estimate of the integral on ("+a+","+b+")="+result);
    }

    long lastReportTime = 0;
    void reportProgress( int id, int completed ) {
        long currentTime = System.currentTimeMillis();
        completedTasks[id] = completed;      // #total completed tasks is sent from workers

        if (lastReportTime + REPORT_PROGRESS_INTERVAL <= currentTime) {
            lastReportTime = currentTime;

            int sum = 0;
            for (int i = 0; i < numWorkers; i++)
                sum += completedTasks[i];

            System.out.println( " " + sum + "/" + numTasks + " (" + 
                                (100 * sum / numTasks) + "%) completed" );
        }
    }

}
