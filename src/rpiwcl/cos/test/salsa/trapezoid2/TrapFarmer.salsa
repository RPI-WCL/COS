module rpiwcl.cos.test.salsa.trapezoid2;

import java.io.*;
import java.util.*;
import rpiwcl.cos.test.salsa.trapezoid2.*;
import rpiwcl.cos.runtime.CosInterface;


/* Trap.salsa -- Parallel Trapezoidal Rule
 *
 * Input: Optinal. a and b, the left and right endpoints of the integral.n the number of trapezoids.
 * Output:  Estimate of the integral from a to b of f(x)
 *    using the trapezoidal rule and n trapezoids.
 *
 * Algorithm:
 *    1.  Each actor calculates "its" interval of
 *        integration.
 *    2.  Each actor estimates the integral of f(x)
 *        over its interval using the trapezoidal rule.
 *    3a. Each actor sends its results to the main actor.
 *    3b. The main actor sums the calculations received from
 *        the individual actors and prints the result.
 *
 * Note:  f(x) is hardwired.
 *
 */

behavior TrapFarmer {
    double      a = 0.0;        // Left endpoint             
    double      b = 1.0;        // Right endpoint            
    int         n = 1024;       // Number of trapezoids      
    int         numWorkers = 2;   // The number of actors   
    long        initialTime;    // Starting Time

    String      nameServer;
    HashMap     conf;

    // progress report
    int         numTasks = 0;
    int REPORT_PROGRESS_INTERVAL = 10000; // report progress every this milliseconds
    int[]       completedTasks;
    String      cosIpAddr;
    int         cosPort;
    String      appName;
    CosInterface cosIf;
    boolean     useCosIf = false;

    void submitJob( int a, int b, int n, int numWorkers, String nameServer, HashMap conf ) {
        this.a = a;
        this.b = b;
        this.n = n;
        this.numTasks = n;
        this.numWorkers = numWorkers;
        this.nameServer = nameServer;
        this.completedTasks = new int[numWorkers];
        
        distributeWork()@
        displayResults(token)@
        endTimer()@currentContinuation;
    }


    Double distributeWork(){
        double h = (b-a)/n; // Trapezoid base length    
        TrapWorker[] workers = new TrapWorker[numWorkers];
        ArrayList uans = new ArrayList();

        // migrate actors to rpi nodes
        ArrayList rpiNodes = (ArrayList)conf.get( "cloud-rpiwcl" );
        int i = 0;
        for (int j = 0; j < rpiNodes.size(); j++) {
            HashMap node = (HashMap)rpiNodes.get( j );
            ArrayList runtimesList = (ArrayList)node.get( "runtimes" );
            ArrayList workersList = (ArrayList)node.get( "workers" );

            for (int k = 0; k < runtimesList.size(); k++) {
                String theater = (String)runtimesList.get( k );
                String workerTasks = (String)workersList.get( k );
                String[] splits = workerTasks.split( "," );

                for (int l = 0; l < splits.length; l++) {
                    String uan = "uan://" + nameServer + "/a" + i;
                    String ual = "rmsp://" + theater + "/a" + i;
                    standardOutput<-println("Sending actor " + uan +" to " + ual );
                    workers[i] = new TrapWorker( i, this.getUAN().toString() ) at  
                        (new UAN( uan ), new UAL( ual ));
                    i++;
                }
            }
        }
        // migrate actors to ec2 nodes
        ArrayList ec2Nodes = (ArrayList)conf.get( "cloud-ec2" );
        for (int j = 0; j < ec2Nodes.size(); j++) {
            HashMap node = (HashMap)ec2Nodes.get( j );
            ArrayList runtimesList = (ArrayList)node.get( "runtimes" );
            ArrayList workersList = (ArrayList)node.get( "workers" );

            for (int k = 0; k < runtimesList.size(); k++) {
                String theater = (String)runtimesList.get( k );
                String workerTasks = (String)workersList.get( k );
                String[] splits = workerTasks.split( "," );

                for (int l = 0; l < splits.length; l++) {
                    String uan = "uan://" + nameServer + "/a" + i;
                    String ual = "rmsp://" + theater + "/a" + i;
                    standardOutput<-println("Sending actor " + uan +" to " + ual );
                    workers[i] = new TrapWorker( i, this.getUAN().toString() ) at  
                        (new UAN( uan ), new UAL( ual ));
                    i++;
                }
            }
        }

        //start computation
        standardOutput<-println(">>>>>>Starting the computation");
        initialTime = System.currentTimeMillis();
        
        double  local_a;   // Left endpoint my process 
        double  local_b;   // Right endpoint my process
        int     total_n = 0;
        i = 0;
        join{
            for (int j = 0; j < rpiNodes.size(); j++) {
                HashMap node = (HashMap)rpiNodes.get( j );
                ArrayList workersList = (ArrayList)node.get( "workers" );

                for (int k = 0; k < workersList.size(); k++) {
                    String workerTasks = (String)workersList.get( k );
                    String[] splits = workerTasks.split( "," );

                    for (int l = 0; l < splits.length; l++) {
                        int local_n = Integer.parseInt( splits[l] );
                        local_a = a + total_n;
                        local_b = local_a + local_n;
                        workers[i]<-trap(local_a, local_b, local_n, h);
                        total_n += local_n;
                        i++;
                    }
                }
            }

            for (int j = 0; j < ec2Nodes.size(); j++) {
                HashMap node = (HashMap)ec2Nodes.get( j );
                ArrayList workersList = (ArrayList)node.get( "workers" );

                for (int k = 0; k < workersList.size(); k++) {
                    String workerTasks = (String)workersList.get( k );
                    String[] splits = workerTasks.split( "," );

                    for (int l = 0; l < splits.length; l++) {
                        int local_n = Integer.parseInt( splits[l] );
                        local_a = a + total_n;
                        local_b = local_a + local_n;
                        workers[i]<-trap(local_a, local_b, local_n, h);
                        total_n += local_n;
                        i++;
                    }
                }
            }


        }@addUpIntegrals(token)@currentContinuation;
    }

    void endTimer(){
        long finalTime = System.currentTimeMillis();
        long runningTime = finalTime - initialTime;
        standardOutput<-println("Running time for Trapezoidal" + 
                                " approximation is "+((double)runningTime/1000)+" sec");
    }

    double addUpIntegrals(Object[] results){
        //receives the integral calculated from each actor's work
        double total = 0.0;
        for (int i = 0; i<results.length; i++){
            total += ((Double)results[i]).doubleValue();
        }
        return total;
    }

    void displayResults(double result){
        standardOutput<-println("With n = "+n+" trapezoids, our estimate of the integral on ("+a+","+b+")="+result);

        if (useCosIf)
            cosIf.close();
    }

    long lastReportTime = 0;
    void reportProgress( int id, int completed ) {
        long currentTime = System.currentTimeMillis();
        completedTasks[id] = completed;      // #total completed tasks is sent from workers

        if (lastReportTime + REPORT_PROGRESS_INTERVAL <= currentTime) {
            lastReportTime = currentTime;

            int sum = 0;
            for (int i = 0; i < numWorkers; i++)
                sum += completedTasks[i];

            System.out.println( " " + sum + "/" + numTasks + " (" + 
                                (100 * sum / numTasks) + "%) completed" );
            
            if (useCosIf)
                cosIf.reportProgress( sum );
        }
    }

}
