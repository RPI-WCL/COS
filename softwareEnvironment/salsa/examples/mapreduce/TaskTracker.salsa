module salsa.examples.mapreduce;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import salsa.examples.mapreduce.*;


behavior TaskTracker {
    int id;
    Mapper mapper;
    Reducer combiner;
    Reducer reducer;
    Context cont;

    ActorReference farmer = null;
    int REPORT_PROGRESS_INTERVAL = 1000; // report progress every this milliseconds

    TaskTracker( int id, Mapper mapper, Reducer combiner, Reducer reducer, String farmerUAN ) {
        this.id = id;
        this.mapper = mapper;
        this.combiner = combiner;
        this.reducer = reducer;
        this.cont = new Context();
        this.farmer = (MapReduce)MapReduce.getReferenceByName( farmerUAN  );
    }

    long lastReportedTime = 0;
    int reportMapProgress( boolean report, int completed ) {
        long currentTime = 0;
        boolean report_ = report;

        if (!report) {
            currentTime = System.currentTimeMillis();
            if (lastReportedTime + REPORT_PROGRESS_INTERVAL <= currentTime) {
                report = true;
            }
        }

        if (report) {
            System.out.println( " Mapper " + id + " completed " + completed );
            System.out.flush();
            lastReportedTime = currentTime;

            farmer<-reportMapProgress( report_, id, completed )@currentContinuation;
        }

        return 0;
    }

    int map( String text ) {
        mapper.map( text, cont );
        return 0;
    }

    HashMap returnMap( Context cont ) {
        return cont.getMap();
    }

    HashMap runMapper( Vector texts ) {
        int numTasks = texts.size();
        cont.clear();

        System.out.println( "Mapper " + id + " started (#tasks = " + numTasks + ")" );
        long startTime = System.currentTimeMillis();

        int task = 0;
        for (task = 0; task < numTasks; task++) {
            token x = map( (String)texts.remove( 0 ) );
            token y = reportMapProgress( false, task );
            x = y;
        }

        reportMapProgress( true, task )@
        standardOutput<-println( "Mapper " + id + " finished (elapsed time = " +
                                 ((double)(System.currentTimeMillis() - startTime) / 1000) + "s)" )@
        runCombiner()@currentContinuation;
    }

    HashMap runCombiner() {
        if (combiner == null) {
            System.out.println( " No combiner defined" );
            return cont.getMap();
        }

        HashMap map = cont.getMap();
        Iterator it = map.entrySet().iterator();
        int numTasks = map.entrySet().size();
        Context context = new Context();

        System.out.println( " Combiner " + id + " started (#tasks = " + numTasks + ")" );
        long startTime = System.currentTimeMillis();

        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry)it.next();
            combiner.reduce( (String)entry.getKey(), (Vector)entry.getValue(), context );
            it.remove();
        }

        System.out.println( " Combiner " + id + " finished (elapsed time = " +
                            ((double)(System.currentTimeMillis() - startTime) / 1000) + "s)" );
        
        returnMap( context )@currentContinuation;
    }

    HashMap runReducer( HashMap map ) {
        if (reducer == null)
            return map;

        Iterator it = map.entrySet().iterator();
        int numTasks = map.entrySet().size();
        Context cont = new Context();

        System.out.println( "  Reducer " + id + " started (#tasks = " + numTasks + ")" );
        long startTime = System.currentTimeMillis();

        int task = 0;
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry)it.next();
            reducer.reduce(  (String)entry.getKey(), (Vector)entry.getValue(), cont );
            // reportReduceProgress( new Integer( task++ ) );
            it.remove();
        }

        System.out.println( "  Reducer " + id + " finished (elapsed time = " +
                            ((double)(System.currentTimeMillis() - startTime) / 1000) + "s)" );

        returnMap( cont )@currentContinuation;
    }
}
